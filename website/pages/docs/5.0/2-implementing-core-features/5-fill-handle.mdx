---
posttype: "docs"
title: Fill handle
metaTitle: "Fill handle"
metaDescription: "ReactGrid docs"
---

#### About fill handling in ReactGrid

Fill handle can be enabled be setting `onFillHandle` prop of the ReactGrid component.

You can copy/paste the following function to your project. If you want to implement a custom fill handle logic, you can modify the function as needed.

```tsx
const handleFill = <T extends CellData | null>(
  selectedArea: NumericalRange,
  fillRange: NumericalRange,
  setData: React.Dispatch<React.SetStateAction<T[][]>>
) => {
  setData((prev) => {
    const next = [...prev];
    // Check if the fill handle is being dragged upwards
    const isFillingUpwards = fillRange.startRowIdx < selectedArea.startRowIdx;
    // Calculate the number of rows and columns in the selected area
    const relativeRowSize = selectedArea.endRowIdx - selectedArea.startRowIdx;
    const relativeColSize = selectedArea.endColIdx - selectedArea.startColIdx;

    // Iterate over the rows and columns in the fill range
    for (let i = fillRange.startRowIdx; i < fillRange.endRowIdx; i++) {
      for (let j = fillRange.startColIdx; j < fillRange.endColIdx; j++) {
        // Skip null cells.
        if (next[i][j] === null) continue;

        const currentCellData = next[i][j] as T;

        // Skip cells of type 'header'
        if (i === 0) continue;

        // Calculate the relative row and column indices within the selected area
        const relativeRowIdx = isFillingUpwards
          ? (selectedArea.endRowIdx - i - 1) % relativeRowSize
          : (i - fillRange.startRowIdx) % relativeRowSize;
        const relativeColIdx = (j - fillRange.startColIdx) % relativeColSize;

        // Get the value from the cell in the selected area that corresponds to the relative row and column indices
        const newValue = prev[selectedArea.startRowIdx + relativeRowIdx][selectedArea.startColIdx + relativeColIdx];

        // Set the value of the cell in the fill range to the value from the selected area
        next[i][j] = {
          ...currentCellData,
          value: newValue ? newValue.value : "",
        };
      }
    }
    return next;
  });
};
```

### Live Demo

import LiveCode from "@/nextra/components/LiveCode.tsx";

import {
  ReactGrid,
  TextCell,
  HeaderCell,
  cellMatrixBuilder,
} from "@silevis/reactgrid";
import {  useState } from "react";

<LiveCode
scope={{
  useState,
  ReactGrid,
  cellMatrixBuilder,
  TextCell, 
  HeaderCell
}}
code={`
const handleFill = <T extends CellData | null>(
  selectedArea: NumericalRange,
  fillRange: NumericalRange,
  setData: React.Dispatch<React.SetStateAction<T[][]>>
) => {
  setData((prev) => {
    const next = [...prev];
    // Check if the fill handle is being dragged upwards
    const isFillingUpwards = fillRange.startRowIdx < selectedArea.startRowIdx;
    // Calculate the number of rows and columns in the selected area
    const relativeRowSize = selectedArea.endRowIdx - selectedArea.startRowIdx;
    const relativeColSize = selectedArea.endColIdx - selectedArea.startColIdx;

    // Iterate over the rows and columns in the fill range
    for (let i = fillRange.startRowIdx; i < fillRange.endRowIdx; i++) {
      for (let j = fillRange.startColIdx; j < fillRange.endColIdx; j++) {
        // Skip null cells.
        if (next[i][j] === null) continue;

        const currentCellData = next[i][j] as T;

        // Skip cells of type 'header'
        if (i === 0) continue;

        // Calculate the relative row and column indices within the selected area
        const relativeRowIdx = isFillingUpwards
          ? (selectedArea.endRowIdx - i - 1) % relativeRowSize
          : (i - fillRange.startRowIdx) % relativeRowSize;
        const relativeColIdx = (j - fillRange.startColIdx) % relativeColSize;

        // Get the value from the cell in the selected area that corresponds to the relative row and column indices
        const newValue = prev[selectedArea.startRowIdx + relativeRowIdx][selectedArea.startColIdx + relativeColIdx];

        // Set the value of the cell in the fill range to the value from the selected area
        next[i][j] = {
          ...currentCellData,
          value: newValue ? newValue.value : "",
        };
      }
    }
    return next;
  });
};


interface CellData {
  value: string;
  template: React.ComponentType<any>;
  style?: React.CSSProperties;
}

const initialColumns: Column[] = [
  { width: 180, resizable: true, minWidth: 80 },
  { width: 180, resizable: true, minWidth: 80 },
  { width: 180, resizable: true, minWidth: 80 },
  { width: 180, resizable: true, minWidth: 80 },
];

const headerRow = ["Name", "Surname", "Email", "City"];

const initialRows: Row[] = Array.from({ length: 5 }, (_, idx) => {
  if (idx === 0) return { height: "30px", reorderable: false };
  return { height: "min-content", reorderable: true };
});

const dataRows = [
  ["Jake", "Smith", "j.smith@gmail.com", "New York"],
  ["Emily", "Jones", "e.jones@hotmail.com", "Paris"],
  ["Liam", "Brown", "l.brown@yahoo.com", "Tokyo"],
  ["Sophia", "Taylor", "s.taylor@gmail.com", "Sydney"],
];

const initialGridData: CellData[][] = [headerRow, ...dataRows].map(
  (row, rowIdx) =>
    row.map((cellValue, index) => {
      const isHeaderRow = rowIdx === 0;

      if (isHeaderRow) {
        return {
          value: cellValue,
          template: HeaderCell,
          style: {
            backgroundColor: "#55bc71",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontWeight: "bold",
          },
        };
      }

      return {
        value: cellValue,
        template: TextCell,
      };
    })
);

function App() {
  const [columns, setColumns] = useState<Array<Column>>(initialColumns);
  const [rows, setRows] = useState<Array<Row>>(initialRows);
  const [gridData, setGridData] = useState<(CellData | null)[][]>(initialGridData);

  const cells = cellMatrixBuilder(({ setCell }) => {
    gridData.forEach((row, rowIdx) => {
      row.forEach((cell, colIdx) => {
        if (cell === null) return;

        setCell(rowIdx, colIdx, cell.template, {
          value: cell.value,
          style: cell.style,
          onValueChanged: (data) => {
            setGridData((prev) => {
              const next = [...prev];
              if (next[rowIdx][colIdx] !== null) {
                next[rowIdx][colIdx].value = data;
              }
              return next;
            });
          },
        });
      });
    });
  });

  return (
    <div>
      <ReactGrid
        id="example"
        initialFocusLocation={{ rowIndex: 2, colIndex: 1 }}
        onFillHandle={(selectedArea, fillRange) => 
          handleFill(selectedArea, fillRange, setGridData)}
        rows={rows}
        columns={columns}
        cells={cells}
      />
    </div>
  );
}

render(<App />, document.getElementById("root"));
`}
/>